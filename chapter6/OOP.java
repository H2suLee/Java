package chapter6;

// p212~

public class OOP {

	// 객체 지향 프로그래밍(OOP, Object-oriented programming)
	// 부품에 해당하는 객체를 먼저 하나씩 설계(모델링)하고, 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
	
	
	// 클래스 선언: 객체의 대표 이름을 하나 결정하고, 이것을 클래스 이름으로 정함 = 설계도 만들기
	// public class Car{ }
	// 객체 지향 프로그래밍에서 클래스는 최소 두 개의 클래스가 필요. 라이브러리 클래스 n개 / 실행용 클래스 1개
	
	
	// 객체 생성: new 연산자를 활용. new 연산자는 객체를 생성시키는 연산자임.
	// new 클래스()는 생성한 객체의 번지수를 나타냄. 이를 클래스 변수에 저장하면 클래스 변수를 통해 객체를 사용할 수 있음.
	// 클래스 변수 = new 클래스();
	// 클래스는 하나지만, new 연산자를 사용한 만큼 객체가 메모리에 생성됨. 
	// 이러한 객체들은 클래스의 인스턴스들임. 같은 클래스로부터 생성되었지만 각각의 객체(인스턴스)는 자신만의 고유 데이터를 가지면서 메모리에서 활동
	
	// 클래스의 구성 멤버 : 필드, 생성자, 메소드
	
	// 필드: 객체의 데이터가 저장되는 곳, 변수와 선언 방식이 비슷, 그러나 변수는 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸되지만, 필드는 객체가 소멸되지 않는 한 객체와 함께 존재
	// 필드를 사용한다는 것은 필드 값을 읽고 변경한다는 것
	// 클래스 외부에서 필드를 사용하려면 객체를 먼저 생성해야 함
	// 외부에서 필드를 사용하려면 [변수.필드명]의 문법을 따름
	// 도트 연산자는 객체 접근 연산자. 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 쓴다.
	// 필드 초기화: 필드를 선언할 때 초기값을 주거나, 생성자에서 초기값을 줄 수도 있다.
	
	
	// 생성자: 객체 생성 시 초기화 담당, new 연산자로 호출됨. 클래스 이름으로 있고 리턴 타입이 없다
	// 라이브러리 클래스에서 생략해도 java가 자동으로 public 클래스() {} 이렇게 만들어 준다.
	// 그래서 외부 클래스에서 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성할 수 있는 것임
	// 자동으로 만들어짐에도 명시적으로 선언하는 이유는, 다양한 값으로 초기화하기 위해서
	// 생성자 오버로딩 p238~ 매개변수를 달리하는 생성자를 여러 개 선언하는 것
	
	// 메소드: 객체의 동작에 해당하는 실행 블록, 메소드 이름을 따로 지정해야 한다. (run, getInfo 등..)
	// 메소드 선언: 선언부(리턴타입, 메소드이름, 매개변수선언) / 실행 블록
	// 메소드 오버로딩: 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것. 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 함
	
	
}
